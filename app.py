"""Web app based on Flask containing endpoints made available by the gateway.

    .. moduleAuthor::Nicolas Gach <nicolas@e-nitium.com>

"""
import g
import requests
import werkzeug.exceptions as ex
from auth0 import AuthError, requires_auth, requires_scope
from crypto import Crypto
from decorators import requires_post_params
from enftycontract import EnftyContract
from exceptions import AuthError, LogicError
from flask import Flask, request, jsonify
from logging import DEBUG
from rq import Queue
from txmanager import TxDbManager
from worker import conn
from worker_scripts import process_mint, process_transfer, process_burn

#contract : 0x855539e32608298cF253dC5bFb25043D19692f6a
#upgradeable : 0xdE2b51ba8888e401725Df10328EE5063fdaF1a3E

app = Flask(__name__)
app.logger.setLevel(DEBUG)

q_high = Queue('high', connection = conn)
q_low = Queue('low', connection = conn)

@app.route('/')
def index():
    """Base route for the app

    :return: Static json
    
    | Doesn't do shit
    |
    """
    response = {}
    response['callresponse'] = 'ok home'
    return jsonify(response)

@app.route('/test_nonce/<testAddress>', methods=['GET'])
def test_nonce(testAddress):
    """Test endpoint to figure out nocne values in db- to be removed after demo

    :param testAddress: The hexadecimal hex address in string format which nonce are going to be counted for, e.g. "0x000..."
    :type testAddress: String
    :return: JSON containing the nonce value
    :rtype: JSON

    | Example of return value :

    .. code-block:: javascript

        {"nonce": 71}

    |

    """
    tx_db_manager = TxDbManager.get_tx_db_manager(g.DATABASE_URL, 'gatewayengine')
    db_nonce = tx_db_manager.get_highest_nonce(testAddress)
    response = {"nonce": db_nonce}
    return jsonify(response)

@app.route('/post_ipfs', methods=['POST'])
@requires_auth
def post_ipfs():
    """IPFS posting endpoint

    :raises AuthError: AuthError raised if authentication towards Auth0 is unsuccessful
    :raises LogicError: LogicError raised if no file is provided in the request
    :return: Returns the response from the Infura-managed IPFS network
    :rtype: JSON

    | Example of return value :
    
    .. code-block:: javascript

        {
            "Name":"a017Q00000JvZN7QAN_token_2022-01-18 12-18-16Z.json",
            "Hash":"QmQ6TxWJG6oEEuZdNQDrBLcfpiswkCvVequJPzZr4C4Ng6",
            "Size":"243"
        }

    |

    """
    if not requires_scope("access:gateway"): raise AuthError({"code": "Unauthorized", "description": "You don't have access to this resource"}, 403)
    if not "file" in request.files: raise LogicError({"code": "Bad Request", "description": "No file input in request"}, 400)
    app.logger.debug('File content %s',request.files['file'].read())
    params = {'file': request.files['file'].read()}
    response = requests.post(g.INFURA_IPFS_URL + '/api/v0/add', files=params, auth=(g.IPFS_PROJECT_ID, g.IPFS_PROJECT_SECRET))
    app.logger.debug('Response %s', response)
    return response.text

@app.route('/mint', methods=['POST'])
@requires_auth
@requires_post_params(['recipient_address', 'token_hash', 'bol_id'])
def mint():
    """Endpoint for token minting

    :param recipient_address: Expected parameter in the POST form-data body, on-chain address of the token's recipient
    :type recipient_address: String
    :param token_hash: Expected parameter in the POST form-data body, IPFS hash of the token's metadata file
    :type token_hash: String
    :param bol_id: Expected parameter in the POST form-data body, Salesforce ID of the Bill_Of_Lading__c record to which the token should be attached. Used in writing the transaction log entry in the postgre database.
    :type bol_id: String
    :raises AuthError: AuthError raised if authentication towards Auth0 is unsuccessful
    :raises LogicError: LogicError raised if the Infura-managed IPFS service is unavailable (couldn't retrieve the token's metadata)
    :return: Transaction receipt generated by the gateway
    :rtype: JSON

    | NB: this endpoint calls enftycontract and tx_db_manager class methods which themselves can raise exceptions, see the related documentation.
    | If any of the expected parameters are missing from the form-data body, an exception will be raised.
    | Example of return value: 
    
    .. code-block:: javascript

        {
            "job_enqueued":"ok",
            "postgre_id":17,
            "tx_uuid":"b53ece2d-2fcc-492d-a857-c4853379ffb2"
        }

    |

    """
    if not requires_scope("access:gateway"): raise AuthError({"code": "Unauthorized", "description": "You don't have access to this resource"}, 403)
    
    sane_form = sanitize_dict(request.form)
    app.logger.debug('sane_form : %s', sane_form)
    
    EnftyContract.check_addresses(sane_form['recipient_address'])
    EnftyContract.check_minimum_balances(g.OWNER_ACCOUNT)
    
    ipfs_response = requests.post(g.INFURA_IPFS_URL + '/api/v0/block/get', params={'arg': sane_form['token_hash']}, auth=(g.IPFS_PROJECT_ID, g.IPFS_PROJECT_SECRET))
    if not ipfs_response.status_code == 200: raise LogicError({"code": "Request Error", "description": "Token not found on IPFS host"}, 400)

    tx_db_manager = TxDbManager.get_tx_db_manager(g.DATABASE_URL, 'gatewayengine')
    tx_db = tx_db_manager.create_tx_in_db(
        sent_from=g.OWNER_ACCOUNT, 
        to_address=g.OWNER_ACCOUNT,
        bill_of_lading_id=sane_form['bol_id'],
        tx_type='Minting')
    
    nonce = -1
    if 'nonce' in sane_form and int(sane_form['nonce'])>=0:
        app.logger.debug('Nonce forced in transaction with value : {0}'.format(nonce))
        nonce = sane_form['nonce']
    q_high.enqueue(process_mint, args=(tx_db['uuid'], sane_form['recipient_address'], ipfs_response.text, nonce))

    return { 'tx_uuid': tx_db['uuid'], 'job_enqueued' : 'ok', 'postgre_id': tx_db['id']}

@app.route('/transfer', methods=['POST'])
@requires_auth
@requires_post_params(['from_address', 'from_pk', 'to_address', 'token_id', 'vector', 'bol_id'])
def transfer():
    """Endpoint for token transfer

    :param from_address: Expected parameter in the POST form-data body, on-chain address of the token's current owner (assumedly transaction initiator)
    :type recipient_address: String
    :param from_pk: Expected parameter in the POST form-data body, encrypted private key of the transaction sender account (current owner)
    :type from_pk: String
    :param to_address: Expected parameter in the POST form-data body, on-chain address of the token's receiver
    :type to_address: String
    :param token_id: Expected parameter in the POST form-data body, contract-generated ID of the Enfty token, identifying the token in the transfer transaction
    :type token_id: String
    :param vector: Expected parameter in the POST form-data body, encryption vector used to generate from_pk. Used in deencryption.
    :type vector: String
    :param bol_id: Expected parameter in the POST form-data body, Salesforce ID of the Bill_Of_Lading__c record to which the token should be attached. Used in writing the transaction log entry in the postgre database.
    :type bol_id: String
    :raises AuthError: AuthError raised if authentication towards Auth0 is unsuccessful
    :raises LogicError: LogicError raised if the Infura-managed IPFS service is unavailable (couldn't retrieve the token's metadata)
    :return: Transaction receipt generated by the gateway
    :rtype: JSON

    | NB: this endpoint calls enftycontract and tx_db_manager class methods which themselves can raise exceptions, see the related documentation.
    | If any of the expected parameters are missing from the form-data body, an exception will be raised.
    | Example of return value : 

    .. code-block:: javascript

        {
            "job_enqueued":"ok",
            "postgre_id":17,
            "tx_uuid":"b53ece2d-2fcc-492d-a857-c4853379ffb2"
        }

    |

    """
    if not requires_scope('access:gateway'): raise AuthError({"code": "Unauthorized", "description": "You don't have access to this resource"}, 403)
    
    sane_form = sanitize_dict(request.form)
    app.logger.debug('sane_form : %s', sane_form)
    from_pk = Crypto.decrypt_sf_aes(sane_form['from_pk'], g.AES_KEY, sane_form['vector'])
    
    EnftyContract.check_addresses(sane_form['from_address'], sane_form['to_address'])
    EnftyContract.check_minimum_balances(sane_form['from_address'])
    
    tx_db_manager = TxDbManager.get_tx_db_manager(g.DATABASE_URL, 'gatewayengine')
    tx_db = tx_db_manager.create_tx_in_db(
        sent_from=sane_form['from_address'], 
        to_address=sane_form['to_address'],
        bill_of_lading_id=sane_form['bol_id'],
        tx_type='Transfer',
        from_address=sane_form['from_address'],
        token_id=sane_form['token_id'])
    nonce = -1
    if 'nonce' in sane_form and int(sane_form['nonce']) >=0:
        app.logger.debug('Nonce forced in transaction with value : {0}'.format(nonce))
        nonce = sane_form['nonce']
    q_high.enqueue(process_transfer, args=(tx_db['uuid'], sane_form['from_address'], from_pk, sane_form['to_address'], sane_form['token_id'], nonce))
    return { 'tx_uuid': tx_db['uuid'], 'job_enqueued' : 'ok', 'postgre_id': tx_db['id'] }

@app.route('/burn', methods=['POST'])
@requires_auth
@requires_post_params(['token_id', 'from_address', 'from_pk', 'vector', 'bol_id'])
def burn():
    """Endpoint for token burning

    :param from_address: Expected parameter in the POST form-data body, on-chain address of the token's current owner (assumedly transaction initiator)
    :type recipient_address: String
    :param from_pk: Expected parameter in the POST form-data body, encrypted private key of the transaction sender account (current owner)
    :type from_pk: String
    :param token_id: Expected parameter in the POST form-data body, contract-generated ID of the Enfty token, identifying the token in the transfer transaction
    :type token_id: String
    :param vector: Expected parameter in the POST form-data body, encryption vector used to generate from_pk. Used in deencryption.
    :type vector: String
    :param bol_id: Expected parameter in the POST form-data body, Salesforce ID of the Bill_Of_Lading__c record to which the token should be attached. Used in writing the transaction log entry in the postgre database.
    :type bol_id: String
    :raises AuthError: AuthError raised if authentication towards Auth0 is unsuccessful
    :raises LogicError: LogicError raised if the Infura-managed IPFS service is unavailable (couldn't retrieve the token's metadata)
    :return: Transaction receipt generated by the gateway
    :rtype: JSON

    | NB: this endpoint calls enftycontract and tx_db_manager class methods which themselves can raise exceptions, see the related documentation.
    | If any of the expected parameters are missing from the form-data body, an exception will be raised.
    | Example of return value : 
    
    .. code-block:: javascript

        {
            "job_enqueued":"ok",
            "postgre_id":17,
            "tx_uuid":"b53ece2d-2fcc-492d-a857-c4853379ffb2"
        }

    |

    """
    if not requires_scope('access:gateway'): raise AuthError({"code": "Unauthorized", "description": "You don't have access to this resource"}, 403)
    
    sane_form = sanitize_dict(request.form)
    app.logger.debug('sane_form : %s', sane_form)
    from_pk = Crypto.decrypt_sf_aes(sane_form['from_pk'], g.AES_KEY, sane_form['vector'])
    
    EnftyContract.check_addresses(sane_form['from_address'])
    EnftyContract.check_minimum_balances(sane_form['from_address'])
    
    tx_db_manager = TxDbManager.get_tx_db_manager(g.DATABASE_URL, 'gatewayengine')
    tx_db = tx_db_manager.create_tx_in_db(
        sent_from=sane_form['from_address'],
        to_address=None,
        bill_of_lading_id=sane_form['bol_id'],
        tx_type='Burn',
        from_address=sane_form['from_address'],
        token_id=sane_form['token_id'])
    nonce = -1
    if 'nonce' in sane_form and int(sane_form['nonce']) >=0:
        app.logger.debug('Nonce forced in transaction with value : {0}'.format(nonce))
        nonce = sane_form['nonce']
    q_high.enqueue(process_burn, args=(tx_db['uuid'], sane_form['from_address'], from_pk, sane_form['token_id'], nonce))
    return { 'tx_uuid': tx_db['uuid'], 'job_enqueued' : 'ok', 'postgre_id': tx_db['id'] }

@app.route('/tokenURI/<tokenId>', methods=['GET'])
@requires_auth
def getTokenURI(tokenId):
    """Endpoint for retrieving the metadata associated to the provided token ID (contract-generated).

    :param tokenId: Necessary query parameter, the contract-generated ID of the token to be handled
    :type tokenId: String
    :raises AuthError: AuthError raised if authentication towards Auth0 is unsuccessful
    :return: Token metadata file content (assumedly JSON)
    :rtype: String

    | The returned value is not pure JSON as it is prefixed and suffixed with bytes, the actual JSON content needs to be parsed / extracted client-side.
    | Example of return value :

    .. code-block:: javascript

        {
            "bill_of_lading_title":"BoL extraction json",
            "bill_of_lading_sf_id":"a017Q00000JvZN7QAN",
            "bill_of_lading_n":"QSKJHD982",
            "vessel":"MV Enitium",
            "port_of_loading":"Dunkerque",
            "port_of_discharge":"New York Harbor",
            "name":"BOL-0000008"
        }

    |

    """
    if not requires_scope('access:gateway'): raise AuthError({"code": "Unauthorized", "description": "You don't have access to this resource"}, 403)
    contract = EnftyContract.get_enfty_contract()
    token_uri = contract.get_token_uri(tokenId)
    return token_uri

@app.route('/decrypt_test', methods=['POST'])
@requires_auth
def decrypt_test():
    """Key decription based on encryption key in the AES standard and on an encryption intialization vector.

    :param content: Expected parameter in the urlencoded body of the POST request, the content to be decrypted 
    :type content: String
    :param vector: Expected parameter in the urlencoded body of the POST request, the vector to be used (16 bytes)
    :type vector: String
    :return: Decrypted content as string
    :rtype: String

    |

    """
    key = g.AES_KEY
    return Crypto.decrypt_sf_aes(request.form['content'], key, request.form['vector'])

@app.errorhandler(500)
def internal_error(e):
    """Error Handler for code 500

    :param e: Error to be handled
    :type e: Flask exception
    :return: Page content to be displayed following a code 500 error 
    :rtype: HTML

    |

    """
    return '<p>Internal Error occurred'

@app.errorhandler(LogicError)
def handle_logic_error(ex):
    """Error Handler for LogicError exception type

    :param ex: Error to be handled
    :type ex: LogicError
    :return: JSON response to be returned following a LogicError, contains the error code & error message
    :rtype: JSON

    | Example of return value : 
    
    .. code-block:: javascript

        {
            "status_code": 400, 
            "error": {
                "code": "Request Error", 
                "description": "Token not found on IPFS host"
            }
        }

    |

    """
    response = jsonify(ex.error)
    response.status_code = ex.status_code
    return response

@app.errorhandler(AuthError)
def handle_auth_error(ex):
    """Error Handler for AuthError exception type

    :param ex: Error to be handled
    :type ex: AuthError
    :return: JSON response to be returned following a AuthError, contains the error code & error message
    :rtype: JSON

    | Example of return value : 
    
    .. code-block:: javascript

        {
            "status_code": 400, 
            "error": {
                "code": "Authentication Error", 
                "description": "Request has no authentication header"
            }
        }

    |

    """
    response = jsonify(ex.error)
    response.status_code = ex.status_code
    return response

def sanitize_dict(dict):
    """Utility method sanitizing dict provided as parameter. Used to sanitize POST form-data input mostly. At the moment, a stripping utility.

    :param dict: Dictionnary to be sanitized
    :type dict: Dictionnary
    :return: Sanitized dictionnary
    :rtype: Dictionnary

    |

    """
    sane_form = {}
    for key in dict: sane_form[key] = dict[key].strip()
    return sane_form

if __name__ == '__main__':
    # Threaded option to enable multiple instances for multiple user access support
    app.run(threaded=True, debug=True, port=5000)